yhfin:
  web:
    #是否开启swagger配置
    swagger: true
  data:
    #数据源实例注入 配置
    config: risk,redis,memory
    #内存数据库配置
    memory:
      #通过kettle同步内存数据配置
      kettle:
        #执行kettle文件的job名称
        job: H2memoryDataSynJob
        #执行kettle文件的job,需要的配置信息(数据库信息等)
        properties: C:/Users/youlangta/.kettle/kettle.properties
        #执行kettle文件的job对应的仓库
        reposity:
        #执行kettle文件的job对应的仓库的文件夹路径
         path: F:/kettle
      #内存数据源名称
      dataSourceName: memoryDataSource
      #内存数据源jdbc操作实例名称
      jdbcname: memoryJdbcOperations
      #内存数据源路径配置
      url: jdbc:h2:mem:memorydb
      #内存数据源web登录用户名
      username: sa
      #内存数据源web登录用户名对应的密码
      password:
      #内存数据库驱动类型
      driverClassName: org.h2.Driver
      #内存数据源 生命式数据源 事物实例名称
      transactionManager: MemorytransactionManager
    #风控数据库配置
    risk:
      #风控数据库名称
      dataSourceName: riskDataSource
      #风控数据库jdbc操作实例名称
      jdbcname: riskJdbcOperations
      #风控数据库连接配置url
      url: jdbc:oracle:thin:@localhost:1521:orcl
      #风控数据库登录用户名
      username: RISK_DEV
      #风控数据库登录密码
      password: RISK_DEV
      #风控数据源驱动类型
      driverClassName: oracle.jdbc.OracleDriver
      #风控数据源 生命式数据源 事物实例名称
      transactionManager: RisktransactionManager
    #sql配置
    tableSqls:
      riskSetQueryRiskIdAll: SELECT I_RISK_ID FROM RISKSET WHERE I_RISK_ID > 0
      riskSetQueryFundConfig: SELECT I_RISK_ID , VC_CONTROL_LAY , VC_CONTROL_VALUE , VC_CONTROL_DEBAR,VC_CONTROL_TYPE  FROM RISKSET WHERE I_RISK_ID = ?
      riskIndexQueryFundConfig: SELECT I_RISK_ID , I_TYPE , I_RISK_CONTROL_NO , VC_FUND_TYPE,VC_FUND_VALUE,VC_FUND_DEBAR,VC_CONTROL_TYPE  FROM RISK_INDEX WHERE  I_RISK_ID = ? AND I_RISK_CONTROL_NO = ? AND I_TYPE = ?
      riskFundScopeQuery: SELECT A.I_RISK_ID,A.VC_OPERATE_FLAG,A.VC_CONTROL_TYPE,A.VC_VALUE,A.I_INDEX,A.I_CONFIG_ID,A.I_PARENT_ID,A.I_TYPE,A.VC_CTL_BS FROM RISK_FUND_SCOPE A WHERE A.I_RISK_ID = ?
      riskFundScopeCfgQuery: SELECT A.I_BOUND_ID,A.VC_CHECK_TABLE,A.VC_TABLE_SHORT,A.VC_CHECK_FIELD,A.VC_CALCU_CHECK_FIELD,A.VC_NEED_CALCU_CHECK_FIELD,A.VC_CALCU_JOIN_SQL,A.VC_NEED_CALCU_JOIN_SQL FROM RISK_FUND_SCOPE_CFG A WHERE A.I_BOUND_ID = ?
      riskSetControlQuery: SELECT A.I_RISK_ID FROM RISKSET_CONTORL A WHERE A.I_RISK_ID = ?
      riskSetControlUpdate: UPDATE RISKSET_CONTORL A SET A.VC_CONTROL_SQL = ? WHERE A.I_RISK_ID = ?
      riskSetControlInsert: INSERT INTO RISKSET_CONTORL  (I_RISK_ID,VC_CONTROL_SQL) VALUES (?,?)
      riskIndexBaseConfigQuery: SELECT A.I_RISK_ID,A.I_RISK_CONTROL_NO,A.I_TYPE,A.VC_VALUE  FROM RISK_INDEX A  WHERE A.I_RISK_ID = ?
      riskStockBoundQuery: SELECT A.I_INDEX,A.I_RISK_ID,A.I_RISK_CONTROL_NO,A.I_TYPE,A.VC_OPERATE_FLAG,A.VC_CONTROL_TYPE,A.VC_VALUE,A.C_LIKECURR,A.VC_CTL_BS,A.I_CONFIG_ID,A.I_PARENT_ID,A.I_CONFIG_TYPE FROM RISK_STOCK_BOUND A WHERE A.I_RISK_ID = ? AND A.I_RISK_CONTROL_NO = ? AND A.I_TYPE = ?
      riskStockBoundCfgQuery: SELECT A.I_BOUND_ID,A.VC_CHECK_TABLE,A.VC_TABLE_SHORT,A.VC_CHECK_FIELD,A.VC_CALCU_CHECK_FIELD,A.VC_NEED_CALCU_CHECK_FIELD,A.VC_CALCU_JOIN_SQL,A.VC_NEED_CALCU_JOIN_SQL FROM RISK_STOCK_BOUND_CFG  A WHERE A.I_BOUND_ID = ?
      riskIndexUpdate: UPDATE RISK_INDEX A SET A.VC_STOCKBOUND_DYNAMIC_SQL = ? , A.VC_STOCKBOUND_SQL = ?  ,A.VC_STOCKS_VALUE_SQL = ? ,A.VC_ENTRUST_VALUE_SQL = ? ,A.VC_INST_VALUE_SQL = ? ,A.VC_STATIC_VALUE_SQL = ? ,A.VC_CONNECTION_ID = ?  WHERE A.I_RISK_ID = ? AND A.I_RISK_CONTROL_NO = ? AND A.I_TYPE = ?
      riskFundBoundCfgQuery: SELECT A.I_BOUND_ID,A.VC_LOAD_VALUE_SQL,A.VC_CALCU_SQL,A.VC_NEED_CALCU_SQL,A.VC_PROPERTY_KEY_VALUE FROM RISK_FUND_BOUND_CFG A  WHERE A.I_BOUND_ID = ?
      riskDataQuery: SELECT A.I_RISKDATA_NO,A.VC_STOCK_MAIN_SQL,A.VC_ENTRUST_MAIN_SQL,A.VC_INST_MAIN_SQL,A.VC_STATIC_MAIN_SQL,A.C_CALCU_FUNDBOUND,A.C_NEED_CALCU_FUNDBOUND,A.C_CALCU_STOCKBOUND,A.C_NEED_CALCU_STOCKBOUND,A.C_CALCU_BANKBOUND,A.C_NEED_CALCU_BANKBOUND,A.VC_DATA_SOURCE,A.VC_SQL_AREA FROM RISKDATATABLE A WHERE  A.I_RISKDATA_NO = ?
      riskExtraParamSingleConfigQuery: SELECT A.VC_PARAM_NAME,A.VC_CONFIG_TYPE,A.VC_CONFIG_INFO,A.VC_CONFIG_NEED_PARAM FROM RISK_EXTRA_PARAM_CONFIG A WHERE A.VC_CONFIG_TYPE = ?
      riskExtraParamConfigQuery: SELECT A.VC_PARAM_NAME,A.VC_CONFIG_TYPE,A.VC_CONFIG_INFO,A.VC_CONFIG_NEED_PARAM FROM RISK_EXTRA_PARAM_CONFIG A WHERE A.VC_CONFIG_TYPE != '-1'
      riskFundQuery: SELECT  FUND_ID,I_RISK_ID FROM V_RISK_FUND_VALID_RISK WHERE I_RISK_ID>0 AND FUND_ID = ?
      memoryTableQueryExist: SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC' AND TABLE_NAME = ?
      stockFundCount: SELECT COUNT(A.I_SERIAL_NO) FROM STOCKS A  WHERE A.I_FUND = ?
      backFundCount: SELECT COUNT(A.I_SERIAL_NO) FROM HUIGOU A WHERE A.I_FUND = ?
      depositFundCount: SELECT COUNT(A.I_SERIAL_NO) FROM CASH_SAVINGINACC A WHERE A.I_FUND = ?
      riskTableCfgQuery: SELECT A.TABLENAME,A.LOADE_SQL,A.UPDATE_SQLEX,A.LOADE_SQL1,A.SINDEX,A.SKEY1,A.I_STATE FROM RISK_TABLE_CFG A ORDER BY A.LOAD_WAY DESC
      riskTableCfgQuerySingle: SELECT A.TABLENAME,A.LOADE_SQL,A.UPDATE_SQLEX,A.LOADE_SQL1,A.SINDEX,A.SKEY1,A.I_STATE FROM RISK_TABLE_CFG A  WHERE A.TABLENAME = ?
      memoryViewQuery: SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_SCHEMA = 'PUBLIC'
      memoryTableQuery: SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC' AND TABLE_NAME != 'DUAL' AND TABLE_TYPE = 'TABLE'
      memorySingleTableQuery: SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC' AND TABLE_NAME = ?
      riskSetQuery: SELECT A.I_RISK_ID FROM RISKSET A INNER JOIN RISKSET_CONTORL B ON A.I_RISK_ID = B.I_RISK_ID
      riskSetCalculateQuery: SELECT CASE WHEN C.I_RISK_ID  IS NOT NULL THEN 1 ELSE 0 END AS FUND_SCOPE_CONFIG, B.VC_CONTROL_SQL,A.I_STATE,A.I_UTTERLY_VALUE_FLAG,A.I_PRECONDITION_FLAG,A.EN_CONTROL_VALUE1,A.I_VALVE_TYPE1,A.EN_CONTROL_VALUE2,A.I_VALVE_TYPE2,A.EN_CONTROL_VALUE3,A.I_VALVE_TYPE3,A.I_CONTROL_TYPE,A.C_SAVE_DETAIL,A.VC_DECLARE_TYPE,A.VC_UNIT,A.I_COMPARE_BS,A.VC_FZ_UNIT,A.I_RISK_ID,A.I_RISK_NO,A.VC_RISK_DESCRIPTION,A.VC_DECLARE_TYPE, A.I_BEGIN_DATE,A.I_END_DATE,A.I_LEVEL FROM RISKSET A INNER JOIN RISKSET_CONTORL B ON  A.I_RISK_ID = B.I_RISK_ID LEFT JOIN (SELECT A.I_RISK_ID FROM RISK_FUND_SCOPE A GROUP BY A.I_RISK_ID) C ON C.I_RISK_ID = A.I_RISK_ID    WHERE   A.I_RISK_ID > 0 AND  A.I_CHECKSTATE = 1 AND A.I_RISK_ID = ?
      riskIndexBaseQuery: SELECT A.I_RISK_ID,A.I_RISK_CONTROL_NO,A.I_TYPE,A.VC_VALUE  FROM RISK_INDEX A  WHERE A.I_RISK_ID = ?
      riskTradesQuery: SELECT A.C_TRADE_DIRECTION FROM RISK_TRADES A WHERE A.I_RISK_ID = ?
      correlationPreRiskQUery: SELECT A.I_CORRELATION_RISK_ID FROM CORRELATIONRISK A WHERE A.I_CHECKSTATE = '1' AND A.I_TYPE = '0' AND  A.I_RISK_ID = ?
      riskIndexQuerySingle: SELECT  A.VC_OPERATE_FLAG,A.VC_INDEX_UNIT,A.VC_VALUE_NAME,A.I_RISK_ID,A.I_RISK_CONTROL_NO,A.I_TYPE,A.VC_STOCKBOUND_SQL,A.VC_CONNECTION_ID,A.VC_STOCKS_VALUE_SQL,A.VC_ENTRUST_VALUE_SQL,A.VC_INST_VALUE_SQL,A.VC_STATIC_VALUE_SQL,A.VC_CATCODE,A.VC_STOCKBOUND_DYNAMIC_SQL FROM RISK_INDEX A WHERE A.I_RISK_ID = ? AND A.I_RISK_CONTROL_NO = ? AND A.I_TYPE = ?
      riskViewCfg: SELECT A.VIEW_NAME,A.CREATE_SQL FROM RISK_VIEW_CFG A
      correlationMutexRiskQUery: SELECT A.I_CORRELATION_RISK_ID AS I_RISK_ID FROM CORRELATIONRISK A WHERE A.I_CHECKSTATE = '1' AND A.I_TYPE = '1' AND  A.I_RISK_ID = ? UNION SELECT A.I_RISK_ID AS I_RISK_ID FROM CORRELATIONRISK A WHERE A.I_CHECKSTATE = '1' AND A.I_TYPE = '1' AND  A.I_CORRELATION_RISK_ID = ?
      riskStockBoundQuerySameReport: SELECT B.VC_BOUND_NAME,B.VC_CHECK_FIELD FROM RISK_STOCK_BOUND A INNER JOIN RISK_STOCK_BOUND_CFG B ON A.VC_CONTROL_TYPE = B.I_BOUND_ID WHERE A.C_LIKECURR = '1' AND A.I_RISK_ID = ? AND A.I_RISK_CONTROL_NO = ? AND A.I_TYPE = ?
      riskStockBoundCfgQuerySameReport: SELECT TRIM(A.VC_TABLE_SHORT) AS VC_TABLE_SHORT,TRIM(A.VC_CHECK_FIELD)  AS VC_CHECK_FIELD FROM RISK_STOCK_BOUND_CFG A WHERE A.C_CAN_LIKECURR = 1 AND TRIM(A.VC_CHECK_FIELD) = ?
      riskStockBoundCfgQuerySameReports: SELECT TRIM(A.VC_TABLE_SHORT) AS VC_TABLE_SHORT,TRIM(A.VC_CHECK_FIELD)  AS VC_CHECK_FIELD FROM RISK_STOCK_BOUND_CFG A WHERE A.C_CAN_LIKECURR = 1
      memoryIndexQuery: SELECT INDEX_NAME FROM INFORMATION_SCHEMA.INDEXES WHERE TABLE_SCHEMA = 'PUBLIC'   GROUP BY INDEX_NAME


risk-bus:
  ribbon:
    #请求连接时间
    ConnectTimeout: 250
    #请求处理的超时时间
    ReadTimeout: 2000
    #多所有操作请求都进行重试
    OkToRetryOnAllOperations: true
    #切换实例重试次数
    MaxAutoRetriesNextServer: 2
    #对当前实例的重试次数
    MaxAutoRetries: 1

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            #hystrix默认熔断时间
            timeoutInMilliseconds: 8000

server:
  port: 9018

spring:
  #消息中间件rabbitmq配置
  rabbitmq:
    host: 192.168.100.100
    prot: 5672
    username: admin
    password: 415ilyILY
  cloud:
    stream:
      bindings:
        entry:
           destination: entry-channel
           contentType: application/json
        memory:
          destination: memory-channel
          contentType: application/json
        analy:
           destination: analy-channel
           contentType: application/json
        calculate:
          destination: calculate-channel
          contentType: application/json
        risk:
          destination: risk-channel
          contentType: application/json
        queryCalculate:
          destination: queryCalculate-channel
          contentType: application/json
    loadbalancer:
      retry:
        #重试机制开启
        enabled: true
  #redis集群配置
  redis:
    cluster:
      #redis集群节点配置
      nodes:
        - 192.168.100.100:7001
        - 192.168.100.100:7002
        - 192.168.100.100:7003
        - 192.168.100.100:7004
        - 192.168.100.100:7005
        - 192.168.100.100:7006
  #h2数据库配置
  h2:
    console:
      #h2数据库是否可以允许web端查看
      enabled: true
      settings:
       #h2数据库是否可以允许所有ip端web端查看
        web-allow-others: true



